<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="写在前面本文中的内容并非完全原创，主要来源见文末的参考链接，本人仅作整理工作，用以记录自己的学习过程，由于个人水平有限，故部分内容可能会出现错误，还请包涵 思维导图 HashMap由数组 + 链表 + 红黑树组成 HashMap 中 Node 的 key、value 值均可为null 在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树 Java7 中使用 Entry 来代表">
<meta property="og:type" content="article">
<meta property="og:title" content="Map (一)：HashMap 及 ConcurrentHashMap 解析">
<meta property="og:url" content="http://yoursite.com/2018/05/10/Java-Map-之-HashMap-及-ConcurrentHashMap-解析/index.html">
<meta property="og:site_name" content="Liqingyu&#39;s Blog">
<meta property="og:description" content="写在前面本文中的内容并非完全原创，主要来源见文末的参考链接，本人仅作整理工作，用以记录自己的学习过程，由于个人水平有限，故部分内容可能会出现错误，还请包涵 思维导图 HashMap由数组 + 链表 + 红黑树组成 HashMap 中 Node 的 key、value 值均可为null 在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树 Java7 中使用 Entry 来代表">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2018/05/10/Java-Map-之-HashMap-及-ConcurrentHashMap-解析/思维导图.jpg">
<meta property="og:image" content="http://yoursite.com/2018/05/10/Java-Map-之-HashMap-及-ConcurrentHashMap-解析/Java8%20HashMap%20结构.jpg">
<meta property="og:image" content="http://yoursite.com/2018/05/10/Java-Map-之-HashMap-及-ConcurrentHashMap-解析/单线程%20resize.jpg">
<meta property="og:image" content="http://yoursite.com/2018/05/10/Java-Map-之-HashMap-及-ConcurrentHashMap-解析/多线程%20resize1.jpg">
<meta property="og:image" content="http://yoursite.com/2018/05/10/Java-Map-之-HashMap-及-ConcurrentHashMap-解析/多线程%20resize2.jpg">
<meta property="og:image" content="http://yoursite.com/2018/05/10/Java-Map-之-HashMap-及-ConcurrentHashMap-解析/多线程%20resize3.jpg">
<meta property="og:image" content="http://yoursite.com/2018/05/10/Java-Map-之-HashMap-及-ConcurrentHashMap-解析/多线程%20resize4.jpg">
<meta property="og:image" content="http://yoursite.com/2018/05/10/Java-Map-之-HashMap-及-ConcurrentHashMap-解析/Java8%20ConcurrentHashMap%20结构.jpg">
<meta property="og:image" content="http://yoursite.com/2018/05/10/Java-Map-之-HashMap-及-ConcurrentHashMap-解析/Java7%20ConcurrentHashMap%20结构.jpg">
<meta property="og:updated_time" content="2018-05-11T06:49:23.847Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Map (一)：HashMap 及 ConcurrentHashMap 解析">
<meta name="twitter:description" content="写在前面本文中的内容并非完全原创，主要来源见文末的参考链接，本人仅作整理工作，用以记录自己的学习过程，由于个人水平有限，故部分内容可能会出现错误，还请包涵 思维导图 HashMap由数组 + 链表 + 红黑树组成 HashMap 中 Node 的 key、value 值均可为null 在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树 Java7 中使用 Entry 来代表">
<meta name="twitter:image" content="http://yoursite.com/2018/05/10/Java-Map-之-HashMap-及-ConcurrentHashMap-解析/思维导图.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/05/10/Java-Map-之-HashMap-及-ConcurrentHashMap-解析/"/>





  <title>Map (一)：HashMap 及 ConcurrentHashMap 解析 | Liqingyu's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Liqingyu's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/10/Java-Map-之-HashMap-及-ConcurrentHashMap-解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Li Qingyu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liqingyu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Map (一)：HashMap 及 ConcurrentHashMap 解析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-10T16:55:51+08:00">
                2018-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java-SE/" itemprop="url" rel="index">
                    <span itemprop="name">Java SE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/05/10/Java-Map-之-HashMap-及-ConcurrentHashMap-解析/" class="leancloud_visitors" data-flag-title="Map (一)：HashMap 及 ConcurrentHashMap 解析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文中的内容并非完全原创，主要来源见文末的参考链接，本人仅作整理工作，用以记录自己的学习过程，由于个人水平有限，故部分内容可能会出现错误，还请包涵</p>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><img src="/2018/05/10/Java-Map-之-HashMap-及-ConcurrentHashMap-解析/思维导图.jpg">
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>由数组 + 链表 + 红黑树组成</p>
<p>HashMap 中 Node 的 key、value 值均可为null</p>
<p>在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树<br><img src="/2018/05/10/Java-Map-之-HashMap-及-ConcurrentHashMap-解析/Java8 HashMap 结构.jpg" alt=""></p>
<p>Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 Node，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode</p>
<ul>
<li>链表中的 Node 节点实现了 Map.Entry&lt;K, V&gt; 接口，而红黑树中的 TreeNode 继承自 LinkedHashMap.Entry&lt;K,V&gt; 类，而 LinkedHashMap.Entry&lt;K,V&gt; 类又继承自 HashMap.Node&lt;K,V&gt; 类。即 TreeNode 是 Node 的子类</li>
</ul>
<h3 id="HashMap-中重要的属性"><a href="#HashMap-中重要的属性" class="headerlink" title="HashMap 中重要的属性"></a>HashMap 中重要的属性</h3><p><code>transient Node&lt;K,V&gt;[] table</code> : 存储 Map 键值对元素的数组</p>
<p><code>capacity()</code> : 当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍</p>
<p><code>loadFactor</code> : 负载因子，默认为 0.75</p>
<p><code>threshold</code> : 扩容的阈值，等于 capacity * loadFactor</p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line"></span><br><span class="line">    int h;</span><br><span class="line">    </span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为何如此计算 hash 值暂不清楚</p>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>Java7 是在链表头部插入新节点，Java8 在链表尾部插入新节点</p>
<p>Java7 是先扩容后插入新值的，Java8 先插值再扩容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line"></span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 第三个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作</span><br><span class="line">// 第四个参数 evict 我们这里不关心</span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line"></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line"></span><br><span class="line">    // 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度</span><br><span class="line">    // 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line"></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line"></span><br><span class="line">    // 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">    </span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line"></span><br><span class="line">    else &#123;// 数组该位置有数据</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line"></span><br><span class="line">        // 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是&quot;相等&quot;，如果是，取出这个节点</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            </span><br><span class="line">            e = p;</span><br><span class="line"></span><br><span class="line">        // 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">        </span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line"></span><br><span class="line">        else &#123;</span><br><span class="line"></span><br><span class="line">            // 到这里，说明数组该位置上是一个链表</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line"></span><br><span class="line">                // 插入到链表的最后面(Java7 是插入到链表的最前面)</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line"></span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    </span><br><span class="line">                    // TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 9 个</span><br><span class="line">                    // 会触发下面的 treeifyBin，也就是将链表转换为红黑树</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                    </span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                        </span><br><span class="line">                    break;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 如果在该链表中找到了&quot;相等&quot;的 key(== 或 equals)</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line"></span><br><span class="line">                    // 此时 break，那么 e 为链表中[与要插入的新值的 key &quot;相等&quot;]的 node</span><br><span class="line">                    break;</span><br><span class="line"></span><br><span class="line">                p = e;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // e != null 说明存在旧值的 key 与要插入的 key &quot;相等&quot;</span><br><span class="line">        // 对于我们分析的 put 操作，下面这个 if 其实就是进行 &quot;值覆盖&quot;，然后返回旧值</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">        </span><br><span class="line">            V oldValue = e.value;</span><br><span class="line"></span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line"></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            </span><br><span class="line">            return oldValue;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++modCount;</span><br><span class="line"></span><br><span class="line">    // 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容</span><br><span class="line">    // 由此可以看出 JDK 1.8 中 HashMap 是先插入元素再判断是否进行扩容</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">    </span><br><span class="line">        resize();</span><br><span class="line"></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="数组扩容-resize"><a href="#数组扩容-resize" class="headerlink" title="数组扩容 resize"></a>数组扩容 resize</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line"></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line"></span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line"></span><br><span class="line">    int oldThr = threshold;</span><br><span class="line"></span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line"></span><br><span class="line">    if (oldCap &gt; 0) &#123; // 对应数组扩容</span><br><span class="line"></span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line"></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">            return oldTab;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 将数组大小扩大一倍</span><br><span class="line"></span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line"></span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line"></span><br><span class="line">            // 将阈值扩大一倍</span><br><span class="line"></span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 这里解释了为什么 HashMap 的构造函数中将 initialCapacity 赋给 this.threshold</span><br><span class="line">    else if (oldThr &gt; 0) // 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候</span><br><span class="line"></span><br><span class="line">        newCap = oldThr;</span><br><span class="line"></span><br><span class="line">    else &#123;// 对应使用 new HashMap() 初始化后，第一次 put 的时候</span><br><span class="line"></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line"></span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    // 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候</span><br><span class="line">    // 因为之前对应的步骤没有为 newThr 赋值</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line"></span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line"></span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line"></span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 从这里可以看出构造函数里给 this.threshold 赋的 initialCapacity 值并不是真正的 threshold 值</span><br><span class="line">    threshold = newThr;</span><br><span class="line"></span><br><span class="line">    // 用新的数组大小初始化新的数组</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line"></span><br><span class="line">    table = newTab; // 如果是初始化数组，到这里就结束了，返回 newTab 即可</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    if (oldTab != null) &#123;</span><br><span class="line"></span><br><span class="line">        // 开始遍历原数组，进行数据迁移。</span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line"></span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line"></span><br><span class="line">            if ((e = oldTab[j]) != null) &#123;</span><br><span class="line"></span><br><span class="line">                oldTab[j] = null;</span><br><span class="line"></span><br><span class="line">                // 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了</span><br><span class="line">                if (e.next == null)</span><br><span class="line">                    </span><br><span class="line">                    // 根据 e.hash &amp; (newCap - 1) 计算 oldTab 中的元素在 newTab 中的 index</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line"></span><br><span class="line">                // 如果是红黑树，具体就不展开了</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line"></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line"></span><br><span class="line">                else &#123; </span><br><span class="line"></span><br><span class="line">                    // 这块是处理链表的情况，</span><br><span class="line">                    // 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序</span><br><span class="line">                    // loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表</span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line"></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line"></span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">                    do &#123;</span><br><span class="line"></span><br><span class="line">                        next = e.next;</span><br><span class="line">                        </span><br><span class="line">                        // oldTab 中计算 index 时使用的是 e.hash &amp; (oldCap -1)，注意这里的区别</span><br><span class="line">                        // oldTab[i] 的元素只会被分配到 newTab[i] 或 newTab[i + oldCap] 上</span><br><span class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line"></span><br><span class="line">                            if (loTail == null)</span><br><span class="line"></span><br><span class="line">                                loHead = e;</span><br><span class="line"></span><br><span class="line">                            else</span><br><span class="line"></span><br><span class="line">                                loTail.next = e;</span><br><span class="line"></span><br><span class="line">                            loTail = e;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        else &#123;</span><br><span class="line"></span><br><span class="line">                            if (hiTail == null)</span><br><span class="line"></span><br><span class="line">                                hiHead = e;</span><br><span class="line"></span><br><span class="line">                            else</span><br><span class="line"></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line"></span><br><span class="line">                            hiTail = e;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125; while ((e = next) != null);</span><br><span class="line"></span><br><span class="line">                    if (loTail != null) &#123;</span><br><span class="line"></span><br><span class="line">                        loTail.next = null;</span><br><span class="line"></span><br><span class="line">                        // 第一条链表</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (hiTail != null) &#123;</span><br><span class="line"></span><br><span class="line">                        hiTail.next = null;</span><br><span class="line"></span><br><span class="line">                        // 第二条链表的新的位置是 j + oldCap，这个很好理解</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return newTab;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="get-过程分析"><a href="#get-过程分析" class="headerlink" title="get 过程分析"></a>get 过程分析</h3><ol>
<li><p>计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1)</p>
</li>
<li><p>判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步</p>
</li>
<li><p>判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步</p>
</li>
<li><p>遍历链表，直到找到相等(==或equals)的 key</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line"></span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    </span><br><span class="line">    return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line"></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line"></span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line"></span><br><span class="line">        // 判断第一个节点是否为所需</span><br><span class="line">        if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line"></span><br><span class="line">        if ((e = first.next) != null) &#123;</span><br><span class="line">        </span><br><span class="line">            // 判断是否是红黑树</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"></span><br><span class="line">            // 链表遍历</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p>remove 方法有两个重载版本，本人将其定义为“强匹配”（key 和 value 都匹配）和“弱匹配”（key 匹配即可），接下来只针对“弱匹配”分析，“强匹配”大同小异</p>
<p>remove 的基本思路是通过 key 的 hash 值得到其在 table 中的 index 值，然后对该 index 位置上的链表或树进行查找，若找到则删除且返回旧值（旧值可以为 null），找不到则返回 null</p>
<p>源码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public V remove(Object key) &#123;</span><br><span class="line"></span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    </span><br><span class="line">    return (e = removeNode(hash(key), key, null, false, true)) == null ?</span><br><span class="line">        null : e.value;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">// matchValue 为 false 则代表“弱匹配”</span><br><span class="line">final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,</span><br><span class="line">                           boolean matchValue, boolean movable) &#123;</span><br><span class="line">                           </span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;</span><br><span class="line">    </span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        </span><br><span class="line">        // node 代表与 key 相匹配的节点</span><br><span class="line">        Node&lt;K,V&gt; node = null, e; K k; V v;</span><br><span class="line">        </span><br><span class="line">        // 若头节点即为要找的节点</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            </span><br><span class="line">            node = p;</span><br><span class="line">        </span><br><span class="line">            </span><br><span class="line">        else if ((e = p.next) != null) &#123;</span><br><span class="line">            </span><br><span class="line">            // 在红黑树中查找节点，暂不分析</span><br><span class="line">            if (p instanceof TreeNode)</span><br><span class="line">            </span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            </span><br><span class="line">            // 在链表中查找节点    </span><br><span class="line">            else &#123;</span><br><span class="line">                </span><br><span class="line">                // 此循环最终的结果是</span><br><span class="line">                // 若找到匹配的几点，则 node 指向该节点，p 指向该节点的上一个节点</span><br><span class="line">                // 若找不到，则 node 为 null，p 指向链表的尾节点</span><br><span class="line">                do &#123;</span><br><span class="line">                </span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                         </span><br><span class="line">                        node = e;</span><br><span class="line">                        </span><br><span class="line">                        break;</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    p = e;</span><br><span class="line">                    </span><br><span class="line">                &#125; while ((e = e.next) != null);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // node == null 代表找不到匹配的节点，直接返回 null</span><br><span class="line">        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != null &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            </span><br><span class="line">            // 红黑树删除节点，暂不分析                 </span><br><span class="line">            if (node instanceof TreeNode)</span><br><span class="line">            </span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);</span><br><span class="line">            </span><br><span class="line">            // 若 node == p，则代表 table[index] 的第一个节点即为要找的节点    </span><br><span class="line">            else if (node == p)</span><br><span class="line">            </span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            </span><br><span class="line">            else</span><br><span class="line">            </span><br><span class="line">                p.next = node.next;</span><br><span class="line">                </span><br><span class="line">            ++modCount;</span><br><span class="line">            </span><br><span class="line">            --size;</span><br><span class="line">            </span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            </span><br><span class="line">            return node;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return null;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="HashMap-线程不安全的原因"><a href="#HashMap-线程不安全的原因" class="headerlink" title="HashMap 线程不安全的原因"></a>HashMap 线程不安全的原因</h2><p>主要体现在 resize 时的死循环及使用迭代器时的 fast-fail 上</p>
<h3 id="单线程-resize"><a href="#单线程-resize" class="headerlink" title="单线程 resize"></a>单线程 resize</h3><p><img src="/2018/05/10/Java-Map-之-HashMap-及-ConcurrentHashMap-解析/单线程 resize.jpg" alt=""></p>
<h3 id="多线程并发下的-resize"><a href="#多线程并发下的-resize" class="headerlink" title="多线程并发下的 resize"></a>多线程并发下的 resize</h3><p><img src="/2018/05/10/Java-Map-之-HashMap-及-ConcurrentHashMap-解析/多线程 resize1.jpg" alt=""><br><img src="/2018/05/10/Java-Map-之-HashMap-及-ConcurrentHashMap-解析/多线程 resize2.jpg" alt=""><br><img src="/2018/05/10/Java-Map-之-HashMap-及-ConcurrentHashMap-解析/多线程 resize3.jpg" alt=""><br><img src="/2018/05/10/Java-Map-之-HashMap-及-ConcurrentHashMap-解析/多线程 resize4.jpg" alt=""><br>至此出现循环链表</p>
<h3 id="Fast-fail"><a href="#Fast-fail" class="headerlink" title="Fast-fail"></a>Fast-fail</h3><h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><p>在使用迭代器的过程中如果 HashMap 被修改，那么 ConcurrentModificationException 将被抛出，也即 Fast-fail 策略</p>
<p>通过判断迭代器自己的 modCount 和 HashMap 的 modCount 是否相等来判断是否在迭代的过程中 HashMap 经过修改</p>
<h4 id="线程安全解决方案"><a href="#线程安全解决方案" class="headerlink" title="线程安全解决方案"></a>线程安全解决方案</h4><p>需要保证只通过 HashMap 本身或者只通过 Iterator 去修改数据，不能在 Iterator 使用结束之前使用 HashMap 本身的方法修改数据</p>
<p>多线程条件下，可使用 <code>Collections.synchronizedMap</code> 方法构造出一个同步 Map，或者直接使用线程安全的 ConcurrentHashMap</p>
<hr>
<h2 id="Java8-ConcurrentHashMap"><a href="#Java8-ConcurrentHashMap" class="headerlink" title="Java8 ConcurrentHashMap"></a>Java8 ConcurrentHashMap</h2><p><img src="/2018/05/10/Java-Map-之-HashMap-及-ConcurrentHashMap-解析/Java8 ConcurrentHashMap 结构.jpg" alt=""></p>
<h3 id="Java7-ConcurrentHashMap"><a href="#Java7-ConcurrentHashMap" class="headerlink" title="Java7 ConcurrentHashMap"></a>Java7 ConcurrentHashMap</h3><p>采用锁分段机制</p>
<p>简单地说，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全<br><img src="/2018/05/10/Java-Map-之-HashMap-及-ConcurrentHashMap-解析/Java7 ConcurrentHashMap 结构.jpg" alt=""></p>
<p>ConcurrentHashMap 中重要的属性</p>
<ul>
<li><p><code>concurrencyLevel</code> ：默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的</p>
</li>
<li><p><code>initialCapacity</code> ：初始容量，这个值指的是整个 ConcurrentHashMap 的初始容量，实际操作的时候需要平均分给每个 Segment</p>
</li>
<li><p><code>loadFactor</code> ：负载因子，之前我们说了，Segment 数组不可以扩容，所以这个负载因子是给每个 Segment 内部使用的</p>
</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 这构造函数里，什么都不干</span><br><span class="line"></span><br><span class="line">public ConcurrentHashMap() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ConcurrentHashMap(int initialCapacity) &#123;</span><br><span class="line"></span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line"></span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">    int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?</span><br><span class="line"></span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line"></span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1));</span><br><span class="line"></span><br><span class="line">    this.sizeCtl = cap;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="put-过程分析"><a href="#put-过程分析" class="headerlink" title="put 过程分析"></a>put 过程分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line"></span><br><span class="line">    return putVal(key, value, false);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line"></span><br><span class="line">    if (key == null || value == null) throw new NullPointerException();</span><br><span class="line"></span><br><span class="line">    // 得到 hash 值</span><br><span class="line"></span><br><span class="line">    int hash = spread(key.hashCode());</span><br><span class="line"></span><br><span class="line">    // 用于记录相应链表的长度</span><br><span class="line"></span><br><span class="line">    int binCount = 0;</span><br><span class="line"></span><br><span class="line">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line"></span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line"></span><br><span class="line">        // 如果数组&quot;空&quot;，进行数组初始化</span><br><span class="line"></span><br><span class="line">        if (tab == null || (n = tab.length) == 0)</span><br><span class="line"></span><br><span class="line">            // 初始化数组，后面会详细介绍</span><br><span class="line"></span><br><span class="line">            tab = initTable();</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        // 找该 hash 值对应的数组下标，得到第一个节点 f</span><br><span class="line"></span><br><span class="line">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</span><br><span class="line"></span><br><span class="line">            // 如果数组该位置为空，</span><br><span class="line"></span><br><span class="line">            //    用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了</span><br><span class="line"></span><br><span class="line">            //          如果 CAS 失败，那就是有并发操作，进到下一个循环就好了</span><br><span class="line"></span><br><span class="line">            if (casTabAt(tab, i, null,</span><br><span class="line"></span><br><span class="line">                         new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line"></span><br><span class="line">                break;                   // no lock when adding to empty bin</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容</span><br><span class="line"></span><br><span class="line">        else if ((fh = f.hash) == MOVED)</span><br><span class="line"></span><br><span class="line">            // 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了</span><br><span class="line"></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        else &#123; // 到这里就是说，f 是该位置的头结点，而且不为空</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">            V oldVal = null;</span><br><span class="line"></span><br><span class="line">            // 获取数组该位置的头结点的监视器锁</span><br><span class="line"></span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line"></span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line"></span><br><span class="line">                    if (fh &gt;= 0) &#123; // 头结点的 hash 值大于 0，说明是链表</span><br><span class="line"></span><br><span class="line">                        // 用于累加，记录链表的长度</span><br><span class="line"></span><br><span class="line">                        binCount = 1;</span><br><span class="line"></span><br><span class="line">                        // 遍历链表</span><br><span class="line"></span><br><span class="line">                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line"></span><br><span class="line">                            K ek;</span><br><span class="line"></span><br><span class="line">                            // 如果发现了&quot;相等&quot;的 key，判断是否要进行值覆盖，然后也就可以 break 了</span><br><span class="line"></span><br><span class="line">                            if (e.hash == hash &amp;&amp;</span><br><span class="line"></span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line"></span><br><span class="line">                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line"></span><br><span class="line">                                oldVal = e.val;</span><br><span class="line"></span><br><span class="line">                                if (!onlyIfAbsent)</span><br><span class="line"></span><br><span class="line">                                    e.val = value;</span><br><span class="line"></span><br><span class="line">                                break;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            // 到了链表的最末端，将这个新值放到链表的最后面</span><br><span class="line"></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line"></span><br><span class="line">                            if ((e = e.next) == null) &#123;</span><br><span class="line"></span><br><span class="line">                                pred.next = new Node&lt;K,V&gt;(hash, key,</span><br><span class="line"></span><br><span class="line">                                                          value, null);</span><br><span class="line"></span><br><span class="line">                                break;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    else if (f instanceof TreeBin) &#123; // 红黑树</span><br><span class="line"></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line"></span><br><span class="line">                        binCount = 2;</span><br><span class="line"></span><br><span class="line">                        // 调用红黑树的插值方法插入新节点</span><br><span class="line"></span><br><span class="line">                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line"></span><br><span class="line">                                                       value)) != null) &#123;</span><br><span class="line"></span><br><span class="line">                            oldVal = p.val;</span><br><span class="line"></span><br><span class="line">                            if (!onlyIfAbsent)</span><br><span class="line"></span><br><span class="line">                                p.val = value;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // binCount != 0 说明上面在做链表操作</span><br><span class="line"></span><br><span class="line">            if (binCount != 0) &#123;</span><br><span class="line"></span><br><span class="line">                // 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8</span><br><span class="line"></span><br><span class="line">                if (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line"></span><br><span class="line">                    // 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，</span><br><span class="line"></span><br><span class="line">                    // 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树</span><br><span class="line"></span><br><span class="line">                    //    具体源码我们就不看了，扩容部分后面说</span><br><span class="line"></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line"></span><br><span class="line">                if (oldVal != null)</span><br><span class="line"></span><br><span class="line">                    return oldVal;</span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // </span><br><span class="line"></span><br><span class="line">    addCount(1L, binCount);</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化数组-：initTable"><a href="#初始化数组-：initTable" class="headerlink" title="初始化数组 ：initTable"></a>初始化数组 ：initTable</h3><p>初始化方法中的并发问题是通过对 sizeCtl 进行一个 CAS 操作来控制的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line"></span><br><span class="line">    Node&lt;K,V&gt;[] tab; int sc;</span><br><span class="line"></span><br><span class="line">    while ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line"></span><br><span class="line">        // 初始化的&quot;功劳&quot;被其他线程&quot;抢去&quot;了</span><br><span class="line"></span><br><span class="line">        if ((sc = sizeCtl) &lt; 0)</span><br><span class="line"></span><br><span class="line">            Thread.yield(); // lost initialization race; just spin</span><br><span class="line"></span><br><span class="line">        // CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁</span><br><span class="line"></span><br><span class="line">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line"></span><br><span class="line">                if ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line"></span><br><span class="line">                    // DEFAULT_CAPACITY 默认初始容量是 16</span><br><span class="line"></span><br><span class="line">                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">                    // 初始化数组，长度为 16 或初始化时提供的长度</span><br><span class="line"></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line"></span><br><span class="line">                    // 将这个数组赋值给 table，table 是 volatile 的</span><br><span class="line"></span><br><span class="line">                    table = tab = nt;</span><br><span class="line"></span><br><span class="line">                    // 如果 n 为 16 的话，那么这里 sc = 12</span><br><span class="line"></span><br><span class="line">                    // 其实就是 0.75 * n</span><br><span class="line"></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; 2);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">                // 设置 sizeCtl 为 sc，我们就当是 12 吧</span><br><span class="line"></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return tab;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="链表转红黑树-：treeifyBin"><a href="#链表转红黑树-：treeifyBin" class="headerlink" title="链表转红黑树 ：treeifyBin"></a>链表转红黑树 ：treeifyBin</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123;</span><br><span class="line"></span><br><span class="line">    Node&lt;K,V&gt; b; int n, sc;</span><br><span class="line"></span><br><span class="line">    if (tab != null) &#123;</span><br><span class="line"></span><br><span class="line">        // MIN_TREEIFY_CAPACITY 为 64</span><br><span class="line"></span><br><span class="line">        // 所以，如果数组长度小于 64 的时候，其实也就是 32 或者 16 或者更小的时候，会进行数组扩容</span><br><span class="line"></span><br><span class="line">        if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line"></span><br><span class="line">            // 后面我们再详细分析这个方法</span><br><span class="line"></span><br><span class="line">            tryPresize(n &lt;&lt; 1);</span><br><span class="line"></span><br><span class="line">        // b 是头结点</span><br><span class="line"></span><br><span class="line">        else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">            // 加锁</span><br><span class="line"></span><br><span class="line">            synchronized (b) &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">                if (tabAt(tab, index) == b) &#123;</span><br><span class="line"></span><br><span class="line">                    // 下面就是遍历链表，建立一颗红黑树</span><br><span class="line"></span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = null, tl = null;</span><br><span class="line"></span><br><span class="line">                    for (Node&lt;K,V&gt; e = b; e != null; e = e.next) &#123;</span><br><span class="line"></span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line"></span><br><span class="line">                            new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line"></span><br><span class="line">                                              null, null);</span><br><span class="line"></span><br><span class="line">                        if ((p.prev = tl) == null)</span><br><span class="line"></span><br><span class="line">                            hd = p;</span><br><span class="line"></span><br><span class="line">                        else</span><br><span class="line"></span><br><span class="line">                            tl.next = p;</span><br><span class="line"></span><br><span class="line">                        tl = p;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // 将红黑树设置到数组相应位置中</span><br><span class="line"></span><br><span class="line">                    setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩容：tryPresize"><a href="#扩容：tryPresize" class="headerlink" title="扩容：tryPresize"></a>扩容：tryPresize</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">// 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了</span><br><span class="line"></span><br><span class="line">private final void tryPresize(int size) &#123;</span><br><span class="line"></span><br><span class="line">    // c：size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。</span><br><span class="line"></span><br><span class="line">    int c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY :</span><br><span class="line"></span><br><span class="line">        tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1);</span><br><span class="line"></span><br><span class="line">    int sc;</span><br><span class="line"></span><br><span class="line">    while ((sc = sizeCtl) &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; int n;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        // 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码</span><br><span class="line"></span><br><span class="line">        if (tab == null || (n = tab.length) == 0) &#123;</span><br><span class="line"></span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line"></span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line"></span><br><span class="line">                    if (table == tab) &#123;</span><br><span class="line"></span><br><span class="line">                        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line"></span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line"></span><br><span class="line">                        table = nt;</span><br><span class="line"></span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; 2); // 0.75 * n</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else if (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line"></span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        else if (tab == table) &#123;</span><br><span class="line"></span><br><span class="line">            // 我没看懂 rs 的真正含义是什么，不过也关系不大</span><br><span class="line"></span><br><span class="line">            int rs = resizeStamp(n);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">            if (sc &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line"></span><br><span class="line">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</span><br><span class="line"></span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||</span><br><span class="line"></span><br><span class="line">                    transferIndex &lt;= 0)</span><br><span class="line"></span><br><span class="line">                    break;</span><br><span class="line"></span><br><span class="line">                // 2. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法</span><br><span class="line"></span><br><span class="line">                //    此时 nextTab 不为 null</span><br><span class="line"></span><br><span class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</span><br><span class="line"></span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 1. 将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span><br><span class="line"></span><br><span class="line">            //     我是没看懂这个值真正的意义是什么？不过可以计算出来的是，结果是一个比较大的负数</span><br><span class="line"></span><br><span class="line">            //  调用 transfer 方法，此时 nextTab 参数为 null</span><br><span class="line"></span><br><span class="line">            else if (U.compareAndSwapInt(this, SIZECTL, sc,</span><br><span class="line"></span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br><span class="line"></span><br><span class="line">                transfer(tab, null);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据迁移：transfer"><a href="#数据迁移：transfer" class="headerlink" title="数据迁移：transfer"></a>数据迁移：transfer</h3><p>To do</p>
<h3 id="get-过程分析-1"><a href="#get-过程分析-1" class="headerlink" title="get 过程分析"></a>get 过程分析</h3><ol>
<li><p>计算 hash 值</p>
</li>
<li><p>根据 hash 值找到数组对应位置: (n – 1) &amp; h</p>
</li>
<li><p>根据该位置处结点性质进行相应查找</p>
</li>
</ol>
<ul>
<li><p>如果该位置为 null，那么直接返回 null 就可以了</p>
</li>
<li><p>如果该位置处的节点刚好就是我们需要的，返回该节点的值即可</p>
</li>
<li><p>如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树，后面我们再介绍 find 方法</p>
</li>
<li><p>如果以上 3 条都不满足，那就是链表，进行遍历比对即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line"></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line"></span><br><span class="line">    int h = spread(key.hashCode());</span><br><span class="line"></span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line"></span><br><span class="line">        (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;</span><br><span class="line"></span><br><span class="line">        // 判断头结点是否就是我们需要的节点</span><br><span class="line"></span><br><span class="line">        if ((eh = e.hash) == h) &#123;</span><br><span class="line"></span><br><span class="line">            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</span><br><span class="line"></span><br><span class="line">                return e.val;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果头结点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树</span><br><span class="line"></span><br><span class="line">        else if (eh &lt; 0)</span><br><span class="line"></span><br><span class="line">            // 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)</span><br><span class="line"></span><br><span class="line">            return (p = e.find(h, key)) != null ? p.val : null;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        // 遍历链表</span><br><span class="line"></span><br><span class="line">        while ((e = e.next) != null) &#123;</span><br><span class="line"></span><br><span class="line">            if (e.hash == h &amp;&amp;</span><br><span class="line"></span><br><span class="line">                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))</span><br><span class="line"></span><br><span class="line">                return e.val;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://segmentfault.com/p/1210000010020931/read" target="_blank" rel="noopener">https://segmentfault.com/p/1210000010020931/read</a></li>
<li><a href="https://mp.weixin.qq.com/s/Gdu5D05cOizl1juG-NHLvg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Gdu5D05cOizl1juG-NHLvg</a></li>
<li><a href="https://mp.weixin.qq.com/s/240B5tg_ykwuEJVrOOYNtg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/240B5tg_ykwuEJVrOOYNtg</a></li>
<li><a href="https://blog.csdn.net/fjse51/article/details/55260493" target="_blank" rel="noopener">https://blog.csdn.net/fjse51/article/details/55260493</a></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/08/Java-Map-解析/" rel="next" title="Java Map 概述">
                <i class="fa fa-chevron-left"></i> Java Map 概述
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/10/Java-Map-之-LinkedHashMap-解析/" rel="prev" title="Map (二)：LinkedHashMap 解析">
                Map (二)：LinkedHashMap 解析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Li Qingyu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#写在前面"><span class="nav-number">1.</span> <span class="nav-text">写在前面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思维导图"><span class="nav-number">2.</span> <span class="nav-text">思维导图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap"><span class="nav-number">3.</span> <span class="nav-text">HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-中重要的属性"><span class="nav-number">3.1.</span> <span class="nav-text">HashMap 中重要的属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hash"><span class="nav-number">3.2.</span> <span class="nav-text">hash</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#put"><span class="nav-number">3.3.</span> <span class="nav-text">put</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组扩容-resize"><span class="nav-number">3.4.</span> <span class="nav-text">数组扩容 resize</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get-过程分析"><span class="nav-number">3.5.</span> <span class="nav-text">get 过程分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove"><span class="nav-number">3.6.</span> <span class="nav-text">remove</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap-线程不安全的原因"><span class="nav-number">4.</span> <span class="nav-text">HashMap 线程不安全的原因</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单线程-resize"><span class="nav-number">4.1.</span> <span class="nav-text">单线程 resize</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多线程并发下的-resize"><span class="nav-number">4.2.</span> <span class="nav-text">多线程并发下的 resize</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fast-fail"><span class="nav-number">4.3.</span> <span class="nav-text">Fast-fail</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#产生原因"><span class="nav-number">4.3.1.</span> <span class="nav-text">产生原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程安全解决方案"><span class="nav-number">4.3.2.</span> <span class="nav-text">线程安全解决方案</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java8-ConcurrentHashMap"><span class="nav-number">5.</span> <span class="nav-text">Java8 ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java7-ConcurrentHashMap"><span class="nav-number">5.1.</span> <span class="nav-text">Java7 ConcurrentHashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化"><span class="nav-number">5.2.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#put-过程分析"><span class="nav-number">5.3.</span> <span class="nav-text">put 过程分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化数组-：initTable"><span class="nav-number">5.4.</span> <span class="nav-text">初始化数组 ：initTable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链表转红黑树-：treeifyBin"><span class="nav-number">5.5.</span> <span class="nav-text">链表转红黑树 ：treeifyBin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扩容：tryPresize"><span class="nav-number">5.6.</span> <span class="nav-text">扩容：tryPresize</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据迁移：transfer"><span class="nav-number">5.7.</span> <span class="nav-text">数据迁移：transfer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get-过程分析-1"><span class="nav-number">5.8.</span> <span class="nav-text">get 过程分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考链接"><span class="nav-number">6.</span> <span class="nav-text">参考链接</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Li Qingyu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("", "");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
